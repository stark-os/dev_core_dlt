// ---------------- DEFINITIONS ----------------

//method selection (uncomment to include)
//#define DLT__UNSAFE_ACCESS_ALLOWED

//csts
#define DLT__BCH_PER_LVL  4 //nbr of refs to be stored in each lvl chk
#define DLT__ITM_PER_CHK 16

//data structure
typedef struct {
	ulng len;
	ulng itmSz;
	ref  dat;
} dlt;






// ---------------- BASICS ----------------

//existence
dlt* dlt__new(ulng itmSz);
void dlt__free(dlt* sbj);

/*//unsafe indexing
#ifdef DLT__UNSAFE_ACCESS_ALLOWED //otherwise, internal use only
void dlt__unsafe_get(dlt* sbj, ulng idx, iref dst);
void dlt__unsafe_set(dlt* sbj, ulng idx, iref src);
#endif

//safe indexing
void dlt__safe_get(dlt* sbj, ulng idx, iref dst);
void dlt__safe_set(dlt* sbj, ulng idx, iref src);

//last
boo  dlt__isEmpty(dlt* sbj);
void dlt__last(   dlt* sbj, iref dst);
void dlt__rmLast( dlt* sbj);
void dlt__popLast(dlt* sbj, iref dst);

//push
#ifdef DLT__UNSAFE_ACCESS_ALLOWED //otherwise, internal use only
void dlt__unsafe_push(dlt* sbj, iref src);
#endif
void dlt__safe_push(dlt* sbj, iref src);

//actions as a whole
void dlt__empty(dlt* sbj);
void dlt__overwrite(dlt* sbj, iref src);
void dlt__fullfill( dlt* src, iref src);

//actions between dlts
dlt* dlt__copy(dlt* src);*/
